\chapter{Evaluation}
\label{ch:evaluation}
In this section, we analyze and evaluate the CASC-SAS approach and discuss the findings of the evaluation.
The goal of the evaluation is to derive quantitative and qualitative characteristics of the approach.
These characteristics are used to verify the applicability of the approach in the presented field of application, i.e., the employment of the approach in newly constructed or retrofitted substations.
Furthermore, the characteristics are used to identify limitations and future directions of the approach.

\section{Method}
The evaluation is performed theoretically as well as experimentally.
For the theoretical parts of the evaluation, we employ proofs to demonstrate and guarantee certain characteristics of our approach.
The experimentally performed parts of the evaluation are based on a testbed implementation of our approach and the concepts discussed in \autoref{sec:approach:realization}.
The areas and metrics covered by the different parts of the evaluation are discussed in the following section.

\subsection{Evaluation Areas \& Metrics}
The evaluation of our approach is based on the goal-question-metric (GQM) approach \cite{Basili84,Basili92}.
The GQM approach aims to analyze whether an overall goal was achieved by answering a set of questions that represent the different areas of interest of the evaluation.
These questions are answered by deriving and evaluating quantitative and qualitative metrics.
The evaluation of the CASC-SAS approach covers three areas of interest.
The three areas of interest, i.e., questions to be answered, and their corresponding metrics are defined below:
\begin{description}
    \item[Goal:] Protect the time-constrained and traffic-intensive communication of a newly constructed or retrofitted SAS against domain-typical adversaries and attacks.
    \begin{description}
        \item[Question: Security] Does CASC-SAS provide security against typical SAS adversaries and attacks?
        \begin{description}
            \item[Metric:] Which security, safety, and availability requirements can be satisfied by deploying the approach in a SAS?
            \item[Metric:] Which adversary and system characteristics are assumed?
            \item[Metric:] Which attacks can be mitigated, and how can these attacks be mitigated with regard to their corresponding mitigation strategy?
            \item[Metric:] How does the attack surface of the SAS change?
        \end{description}
        \item[Question: Performance] Is CASC-SAS capable of securing time-constrained and traffic-intensive communication of an SAS in an efficient and scalable manner?
        \begin{description}
            \item[Metric:] Which performance requirements can be satisfied by deploying the approach in a SAS?
            \item[Metric:] Which communication characteristics are assumed?
            \item[Metric:] Which message types are supported?
            % \item Resistance against network exceptions including congestion, delay, jitter, duplicated packets, lost packets, and out-of-order packet delivery
        \end{description}
        \item[Question: Compatibility] Is CASC-SAS a viable solution to enhance the security of newly constructed or retrofitted substations?
        \begin{description}
            \item[Metric:] Which compatibility requirements can be satisfied by deploying the approach in a SAS?
            \item[Metric:] Which device requirements are assumed?
            \item[Metric:] What are the additional costs for SAS construction and retrofitting?
            \item[Metric:] Is the approach feasible with regard to SAS retrofitting?
            % \item Cost-benefit efficiency compared to alternative approaches
        \end{description}
    \end{description}
\end{description}

\subsection{Testbed}
To analyze and evaluate the integration of our approach into the SAS architecture, as discussed in \autoref{sec:approach:realization}, we implemented the approach in hardware and software as a testbed.
The software is implemented component-wise using object-oriented high-level programming languages.
The implementation of the components is mainly based on the programming languages Java and Kotlin.
The implementation is divided into three main packages.
These packages, their sub-packages, and the package interrelationships are shown in \autoref{fig:casc_package_structure}.
The common package contains functionalities that are required by all other parts of the implementation.
Among others, the common package contains classes and interfaces related to message ingress and egress, message serialization, concurrency, and cryptography.
The second package and its sub-packages are dedicated to the CASA components and protocols.
The third package and its sub-packages are dedicated to the SABAAC components and protocols.
To avoid circular dependencies between the packages and achieve loose coupling of components, we employ the dependency inversion principle by using interfaces.
\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{figures/package_structure.drawio.pdf}
    \caption{Structural package diagram of the CASC-SAS testbed implementation.}
    \label{fig:casc_package_structure}
\end{figure}

To be able to conduct experiments while taking the behavior of physical network communication into account, we transformed the software implementation into a physical system by deploying the SABAAC and CASA components to hardware.
In contrast to deterministic software-based analysis, the testbed evaluation results are practice-oriented and transferable to the SAS domain.
The topology of our testbed network is visualized in \autoref{fig:evaluation_test_bed}.
The components depicted in blue represent domain-specific devices of an SAS, including IEDs and MUs.
%and computers that mimic the behavior of domain-specific devices of an SAS
The components depicted in yellow represent intermediate network devices for frame and datagram forwarding on the data link layer and network layer.
The components depicted in red are part of the CASC-SAS approach.
The specific hardware used for the experiments is discussed for each experiment individually in the following sections.
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/network_testbed_color.drawio.pdf}
    \caption{Topology of the CASC-SAS testbed network.}
    \label{fig:evaluation_test_bed}
\end{figure}
%The specific hardware used for the experiments is shown in \autoref{tab:testbed_hardware}.
%We conducted the experiments using a single TTP server that provided the PDP, PAP, PSP, and CAPP services.
%For experiments without real SAS devices, we deployed the PEPs as well as machines that mimic the behavior of domain-specific SAS devices to individual off-the-shelf Raspberry Pi 5 computers.
%For experiments with real IEDs and MUs, only the PEPs were deployed to Raspberry Pi 5 computers.
%
%The simulation and testbed strategy have differing advantages and disadvantages.
%On the one hand, the simulation strategy has the advantage of repeatability and reproducibility due to deterministic behavior, whereas the behavior of the testbed is non-deterministic.

\section{Security Analysis}
In this section, an analysis of the security of the CASC-SAS approach and its core concepts CASA and SABAAC will be conducted.
The primary objective of the security analysis is to demonstrate and guarantee certain security-related characteristics of the approach.
As the security analysis is performed theoretically, proofs will be provided demonstrating that the approach is able to mitigate adversarial attacks that endanger these security-related characteristics.
\begin{description}
    \item[Definition.] Unforgeability.\\
    Unforgeability ensures that no adversary can create a valid signature for a message under a policy unless their set of attributes satisfies the policy.
    Unforgeability is defined using a game between a challenger and an adversary:
    \begin{itemize}
        \item Setup: The challenger runs the \texttt{Setup} algorithm to generate the public parameters $PK$ and the master secret key $MSK$. The public parameters are given to the adversary, while the $MSK$ is kept secret.

        \item KeyGen: The adversary can query the \texttt{KeyGen} oracle to obtain private keys for sets of attributes of its choice. The challenger responds with the corresponding private keys.

        \item SignQueries: The adversary can request signatures for messages and policies from the \texttt{Sign} oracle. The oracle returns valid signatures if the queried attributes satisfy the signing policy.

        \item Forgery: The adversary outputs a forged signature $(M^*, T^*, \sigma^*)$ for a message $M^*$ and policy $T^*$. The adversary wins if the following conditions hold:
        \begin{itemize}
            \item The adversary did not request a signature on $(M^*, T^*)$ from the \texttt{Sign} oracle.
            \item The adversary does not possess a private key whose attributes satisfy the policy $T^*$.
            \item The verification algorithm accepts $\sigma^*$ as a valid signature under $T^*$.
        \end{itemize}
    \end{itemize}

    \item[Definition.] Existential Unforgeability under Chosen-Message Attacks (EU-CMA).\\
    An adversary $\mathcal{A}$ is given access to public parameters, hash oracles, and a signing oracle.
    A scheme is secure if $\mathcal{A}$ cannot forge a valid signature $\sigma^*$ for a new message $M^*$ without knowing the signer's full private key.
    In other words, to create an existential forgery, i.e., output a valid pair of message and signature for a new message, an adversary carrying out a CMA can request valid signatures for any message of his choice \cite{Goldwasser1988}.
    The adversary's advantage in this game is its probability of generating a valid forgery.
    We say the ABS scheme is \textit{existentially unforgeable} if the adversary's advantage is negligible.

    \item[Theorem.] $\mathcal{S}_{CASA}$ is EU-CMA secure under the Computational Diffie-Hellman (CDH) assumption in the random oracle model.\\
    \textit{Proof.} After querying the signing oracle, assume $\mathcal{A}$ forges a signature $\sigma^*$ for $M^*$. The challenger interacts with $\mathcal{A}$ as follows:
    \begin{itemize}
        \item \textit{Setup}: The challenger generates $ppk_i$, $p$, and hash oracles \( H_1, H_2, H_3 \) for \( \mathcal{A} \).
        \item \textit{HashQueries}: The challenger responds to \( H_1, H_2, H_3 \) queries with random values, ensuring consistency.
        \item \textit{SigningQueries}: For $M$ and $\mathsf{Att}_{i}$, the challenger computes:
        \[
        \sigma_i = \big(ppk_{i} \cdot H_3(h)\big)^{\chi_i},
        \]
        where $h = H_2(M || \mathsf{Att}_{i})$.
        \item \textit{Forgery}: If \( \mathcal{A} \) outputs \( \sigma^* \) for \( M^* \), the challenger extracts \( g^{ab} \) from \( g, g^a, g^b \), solving the CDH problem.
    \end{itemize}
    Thus, $\mathcal{A}$'s advantage is negligible under the CDH assumption.
    The $\mathcal{S}_{CASA}$ scheme is secure against EU-CMA attacks.

    \item[Definition.] Collusion Attack.\\
    An adversary $\mathcal{A}$ colludes with a TTP and corrupted signers to derive private keys or forge valid signatures.
    The scheme is secure if such a collusion does not compromise honest signers and does not allow forgery.

    \item[Theorem.] $\mathcal{S}_{CASA}$ resists collusion attacks under the Discrete Logarithm Problem (DLP).\\
    \textit{Proof.} Suppose $\mathcal{A}$ colludes with the CAPP to derive $sk_i = (ppk_i, \chi_i)$, then the following steps are performed:
    \begin{itemize}
        \item The CAPP knows $ppk_i = H_1(\mathsf{ID}_i || \mathsf{ATT}_i)^{s}$.
        \item The signer independently chooses $\chi_i$ and the DLP ensures $\mathcal{A}$ cannot derive $\chi_i$ from $y_i = g^{\chi_i}$.
        \item Without $\chi_i$, $\mathcal{A}$ cannot compute:
        \[
        \sigma_i = \big(ppk_i \cdot H_3(h)\big)^{\chi_i}.
        \]
    \end{itemize}
    Thus, collusion cannot compromise security.
    The $\mathcal{S}_{CASA}$ scheme is secure against collusion attacks.

    \item[Definition.] Message Replay.\\
    To perform a message replay, an adversary captures and repeats the messages exchanged between two or more network devices.
    The adversary aims to inject false data into the system, or disrupt the operation of the network devices.

    \item[Theorem.] CASC-SAS protects SAS devices against message replay attacks.\\
    \textit{Proof.} Suppose two SAS devices, $Alice$ and $Bob$, exchange messages over a network.
    We assume that an adversary $\mathcal{A}$, as introduced in \autoref{sec:approach:attacks}, is able to eavesdrop and replay the messages sent from $Alice$ to $Bob$, and vice versa.
    For the exchange of a message $m$ between $Alice$ and $Bob$, as shown in \autoref{fig:attack_message_replay}, the following steps are performed:
    \begin{itemize}
        \item $Alice$ sends the message $m$ to $Bob$ via $PEP_{Alice}$.
        \item To satisfy the security policies I and IV of CASC-SAS, $PEP_{Alice}$ encapsulates $m$ and a sequence number $seq_m$ in a packet $m' = (Alice, Bob, m, seq_m)$ and signs $m'$ to get $m'' = (m', \sigma_{m'})$.
        \item $PEP_{Alice}$ sends $m''$ to $PEP_{Bob}$ using the network. $PEP_{Bob}$ receives $m''$ from $PEP_{Alice}$, verifies the signature $\sigma_{m'}$, sets the last sequence number received from $PEP_{Alice}$ to $seq_m$, and delivers $m$ to $Bob$.
        \item $\mathcal{A}$ eavesdrops the message exchange, receives $m''$ at the same time as $PEP_{Bob}$, and replays $m''$ to $PEP_{Bob}$.
        \item $PEP_{Bob}$ receives $m''$ from $\mathcal{A}$. As $PEP_{Bob}$ already processed a packet from $PEP_{Alice}$ with sequence number $seq_m$, $m''$ is discarded.
    \end{itemize}
    $\mathcal{A}$ gains no advantage by replaying $m''$, as neither false data is injected into $Alice$ or $Bob$, nor is the operation of $Alice$ or $Bob$ disrupted.
    Thus, SAS devices are protected against message replay attacks.
    \begin{figure}
        \centering
        \includegraphics[width=0.75\linewidth]{figures/attack_message_replay.drawio.pdf}
        \caption{Malicious replay of a message exchanged between two PEP-protected SAS devices.}
        \label{fig:attack_message_replay}
    \end{figure}

    \item[Definition.] Message Forgery.\\
    To perform a message forgery, an adversary masquerades as a legitimate device to send malicious messages to other devices.
    By using message forgery, the adversary injects false data into the system, or disrupts the operation of devices.

    \item[Theorem.] CASC-SAS protects SAS devices against message forgery attacks.\\
    \textit{Proof.} Suppose two SAS devices, $Alice$ and $Bob$, exchange messages over a network.
    We assume that only the two devices have the necessary key material to sign and verify exchanged messages.
    As defined in \autoref{sec:approach:attacks}, we assume that an adversary $\mathcal{A}$ is able to initiate arbitrary message exchanges but is unable to bypass or break cryptographic procedures.
    To send a malicious message $m*$ from $\mathcal{A}$ to $Bob$, as shown in \autoref{fig:attack_message_forgery}, $\mathcal{A}$ has to perform the following steps:
    \begin{itemize}
        \item $\mathcal{A}$ creates a message $f$ of its choice.
        \item $\mathcal{A}$ encapsulates $f$ in a packet $m^* = ((Alice, Bob, f, seq_{m^*}), \sigma_{m^*})$, to masquerade as $PEP_{Alice}$.
        \item $\mathcal{A}$ sends $m^*$ to $PEP_{Bob}$.
        \item $PEP_{Bob}$ discards $m^*$ and does not deliver $f$ to $Bob$, as the signature $\sigma_{m^*}$ is not created by $PEP_{Alice}$.
    \end{itemize}
    Since only $PEP_{Alice}$ has the necessary key material to sign messages from $Alice$, $\mathcal{A}$ is unable to masquerade as $Alice$.
    Thus, SAS devices are protected against message forgery attacks.
    \begin{figure}
        \centering
        \includegraphics[width=0.75\linewidth]{figures/attack_message_forgery.drawio.pdf}
        \caption{Forgery of a message by masquerading as a PEP-protected SAS device.}
        \label{fig:attack_message_forgery}
    \end{figure}

    \item[Definition.] Message Modification.\\
    To perform a message modification, an adversary captures and alters messages exchanged between two or more network devices.
    Accordingly, message modification is a special type of message forgery that derives a malicious message from a captured message.

    \item[Theorem.] CASC-SAS protects SAS devices against message modification attacks.\\
    \textit{Proof.} Suppose two SAS devices, $Alice$ and $Bob$, exchange messages over a network.
    As with message forgery, we assume that only $Alice$ and $Bob$ have the necessary key material to sign and verify exchanged messages, and that an adversary $\mathcal{A}$ is unable to bypass or break cryptographic procedures.
    We assume that $\mathcal{A}$ performs the attack using a man in the middle approach, i.e., $Alice$ and $Bob$ are not directly connected and the exchanged messages traverse $\mathcal{A}$.
    The modification of a message $m$ from $Alice$ to $Bob$ using a man in the middle approach is shown in \autoref{fig:attack_message_modification}.
    To carry out a message modification attack, $\mathcal{A}$ has to perform the following steps:
    \begin{itemize}
        \item $Alice$ sends the message $m$ to $PEP_{Alice}$.
        \item To satisfy the security policies I and IV of CASC-SAS, $PEP_{Alice}$ encapsulates $m$ and a sequence number $seq_m$ in a packet $m' = (Alice, Bob, m, seq_m)$ and signs $m'$ to get $m'' = (m', \sigma_{m'})$.
        \item $PEP_{Alice}$ sends $m''$ unintentionally to $\mathcal{A}$ using the network.
        \item $\mathcal{A}$ modifies $m$ and encapsulates the modified message $f$ in a packet $m^* = ((Alice, Bob, f, seq_{m}), \sigma_{m})$.
        \item $\mathcal{A}$ sends $m^*$ to $PEP_{Bob}$.
        \item $PEP_{Bob}$ discards $m^*$ and does not deliver $f$ to $Bob$, as the signature $\sigma_{m'}$ does not match the content of $m^*$.
    \end{itemize}
    Since only $PEP_{Alice}$ has the necessary key material to sign messages from $Alice$, $\mathcal{A}$ is unable to renew the signature after modifying the encapsulated message.
    Thus, SAS devices are protected against message modification attacks.
    \begin{figure}
        \centering
        \includegraphics[width=0.75\linewidth]{figures/attack_message_modification.drawio.pdf}
        \caption{Malicious modification of a message exchanged between two PEP-protected SAS devices.}
        \label{fig:attack_message_modification}
    \end{figure}

    \item[Definition.] Time-Delay Attack.\\
    A time-delay attack is the intentional delaying of time-critical messages in a network.
    To perform a time-delay attack, a man in the middle adversary captures a message sent by a network device, and waits a certain time before forwarding it to the message receiver.
    By maliciously delaying exchanged messages, the adversary may either inject outdated data into the system or disrupt the operation of devices.

    \item[Theorem.] CASC-SAS protects SAS devices against time-delay attacks.\\
    \textit{Proof.} Suppose two SAS devices, $Alice$ and $Bob$, exchange messages over a network in the presence of an adversary $\mathcal{A}$, which performs a time-delay attack using a man in the middle approach.
    The performed time-delay attack is shown in \autoref{fig:attack_time_delay}.
    To carry out a message modification attack, $\mathcal{A}$ has to perform the following steps:
    \begin{itemize}
        \item $Alice$ sends the message $m$ to $PEP_{Alice}$.
        \item To satisfy the security policies I and IV of CASC-SAS, $PEP_{Alice}$ encapsulates $m$ with a timestamp-based sequence number $seq_m$ in a packet $m' = (Alice, Bob, m, seq_m)$ and signs $m'$ to get $m'' = (m', \sigma_{m'})$.
        \item $PEP_{Alice}$ sends $m''$ unintentionally to $\mathcal{A}$ using the network.
        \item $\mathcal{A}$ receives $m''$ and waits a certain time before sending it to $PEP_{Bob}$.
        \item $PEP_{Bob}$ discards $m''$ and does not deliver $m$ to $Bob$, as the sequence number $seq_m$ indicates that the packet was maliciously or accidentally delayed.
    \end{itemize}
    The delay of $m''$ would only be unnoticeable if $\mathcal{A}$ was able to update the sequence number.
    However, as only $PEP_{Alice}$ has the necessary key material to sign messages from $Alice$, $\mathcal{A}$ is unable to update the sequence number.
    Thus, SAS devices are protected against time-delay attacks.
    \begin{figure}
        \centering
        \includegraphics[width=0.75\linewidth]{figures/attack_time_delay.drawio.pdf}
        \caption{Malicious delaying of a message exchanged between two PEP-protected SAS devices.}
        \label{fig:attack_time_delay}
    \end{figure}
    %\item[Theorem.] CASC-SAS protects SAS devices against flooding attacks.\\
    %\textit{Proof.}
\end{description}

\section{Performance Analysis}
\todo{TODO: Performance analysis of CASC-SAS}
\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{figures/rtt-estimation-results.pdf}
    \caption{Impact of authentication schemes on the round-trip latency of packets.}
    \label{fig:rtt_estimation_results}
\end{figure}

\section{Compatibility Analysis}
\todo{TODO: Demonstration of applicability and compatibility analysis of CASC-SAS}
Maybe physical compatibility, communication compatibility, economy ("price compatibility")\dots

\section{Discussion \& Comparison}
\todo{TODO: Discussion of results and comparison to different approaches}
