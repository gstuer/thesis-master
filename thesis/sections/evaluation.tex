\chapter{Evaluation}
\label{ch:evaluation}
In this section, we analyze and evaluate the CASC-SAS approach and discuss the findings of the evaluation.
The goal of the evaluation is to derive quantitative and qualitative characteristics of the approach.
These characteristics are used to verify the applicability of the approach in the presented field of application, i.e., the employment of the approach in newly constructed or retrofitted substations.
Furthermore, the characteristics are used to identify limitations and future directions of the approach.

\section{Method}
The evaluation is performed theoretically as well as experimentally.
For the theoretical parts of the evaluation, formal and informal methods are used to proof certain characteristics of the proposed approach.
The experimentally performed parts of the evaluation are based on a testbed implementation of our approach and the concepts discussed in \autoref{sec:approach:realization}.
The areas and metrics covered by the different parts of the evaluation are discussed in the following section.

\subsection{Evaluation Areas \& Metrics}
The evaluation of our approach is based on the goal-question-metric (GQM) approach \cite{Basili84,Basili92}.
The GQM approach aims to analyze whether an overall goal was achieved by answering a set of questions that represent the different areas of interest of the evaluation.
These questions are answered by deriving and evaluating quantitative and qualitative metrics.
The evaluation of the CASC-SAS approach covers three areas of interest.
The three areas of interest, i.e., questions to be answered, and their corresponding metrics are defined below:
\begin{description}
    \item[Goal:] Protect the time-constrained and traffic-intensive communication of a newly constructed or retrofitted SAS against domain-typical adversaries and attacks.
    \begin{description}
        \item[Question: Security] Does CASC-SAS provide security against typical SAS adversaries and attacks?
        \begin{description}
            \item[Metric:] Which security, safety, and availability requirements can be satisfied by deploying the approach in a SAS?
            \item[Metric:] Which adversary and system characteristics are assumed?
            \item[Metric:] Which attacks can be mitigated, and how can these attacks be mitigated with regard to their corresponding mitigation strategy?
            \item[Metric:] How does the attack surface of the SAS change?
        \end{description}
        \item[Question: Performance] Is CASC-SAS capable of securing time-constrained and traffic-intensive communication of an SAS in an efficient and scalable manner?
        \begin{description}
            \item[Metric:] Which performance requirements can be satisfied by deploying the approach in a SAS?
            \item[Metric:] Which communication characteristics are assumed?
            \item[Metric:] Which message types are supported?
            % \item Resistance against network exceptions including congestion, delay, jitter, duplicated packets, lost packets, and out-of-order packet delivery
        \end{description}
        \item[Question: Compatibility] Is CASC-SAS a viable solution to enhance the security of newly constructed or retrofitted substations?
        \begin{description}
            \item[Metric:] Which compatibility requirements can be satisfied by deploying the approach in a SAS?
            \item[Metric:] Which device requirements are assumed?
            \item[Metric:] What are the additional costs for SAS construction and retrofitting?
            \item[Metric:] Is the approach feasible with regard to SAS retrofitting?
            % \item Cost-benefit efficiency compared to alternative approaches
        \end{description}
    \end{description}
\end{description}

\subsection{Testbed}
To analyze and evaluate the integration of our approach into the SAS architecture, as discussed in \autoref{sec:approach:realization}, we implemented the approach in hardware and software as a testbed.
The software is implemented component-wise using object-oriented high-level programming languages.
The implementation of the components is mainly based on the programming languages Java and Kotlin.
The implementation is divided into three main packages.
These packages, their sub-packages, and the package interrelationships are shown in \autoref{fig:casc_package_structure}.
The common package contains functionalities that are required by all other parts of the implementation.
Among others, the common package contains classes and interfaces related to message ingress and egress, message serialization, concurrency, and cryptography.
The second package and its sub-packages are dedicated to the CASA components and protocols.
The third package and its sub-packages are dedicated to the SABAAC components and protocols.
To avoid circular dependencies between the packages and achieve loose coupling of components, we employ the dependency inversion principle by using interfaces.
\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{figures/package_structure.drawio.pdf}
    \caption{Structural package diagram of the CASC-SAS testbed implementation.}
    \label{fig:casc_package_structure}
\end{figure}

To be able to conduct experiments while taking the behavior of physical network communication into account, we transformed the software implementation into a physical system by deploying the SABAAC and CASA components to hardware.
In contrast to deterministic software-based analysis, the testbed evaluation results are practice-oriented and transferable to the SAS domain.
The topology of our testbed network is visualized in \autoref{fig:evaluation_test_bed}.
The components depicted in blue represent domain-specific devices of an SAS, including IEDs and MUs.
%and computers that mimic the behavior of domain-specific devices of an SAS
The components depicted in yellow represent intermediate network devices for frame and datagram forwarding on the data link layer and network layer.
The components depicted in red are part of the CASC-SAS approach.
The specific hardware used for the experiments is discussed for each experiment individually in the following sections.
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/network_testbed_color.drawio.pdf}
    \caption{Topology of the CASC-SAS testbed network.}
    \label{fig:evaluation_test_bed}
\end{figure}
%The specific hardware used for the experiments is shown in \autoref{tab:testbed_hardware}.
%We conducted the experiments using a single TTP server that provided the PDP, PAP, PSP, and CAPP services.
%For experiments without real SAS devices, we deployed the PEPs as well as machines that mimic the behavior of domain-specific SAS devices to individual off-the-shelf Raspberry Pi 5 computers.
%For experiments with real IEDs and MUs, only the PEPs were deployed to Raspberry Pi 5 computers.
%
%The simulation and testbed strategy have differing advantages and disadvantages.
%On the one hand, the simulation strategy has the advantage of repeatability and reproducibility due to deterministic behavior, whereas the behavior of the testbed is non-deterministic.

\section{Security Analysis}
\todo{TODO: Security analysis for CASA}
\begin{description}
    \item[Definition I.] Unforgeability.\\
    Unforgeability ensures that no adversary can create a valid signature for a message under a policy unless their set of attributes satisfies the policy.
    Formally, unforgeability is defined using a game between a challenger and an adversary:
    \begin{itemize}
        \item Setup: The challenger runs the \texttt{Setup} algorithm to generate the public parameters $PK$ and the master secret key $MSK$. The public parameters are given to the adversary, while the $MSK$ is kept secret.

        \item KeyGen: The adversary can query the \texttt{KeyGen} oracle to obtain private keys for sets of attributes of its choice. The challenger responds with the corresponding private keys.

        \item SignQueries: The adversary can request signatures for messages and policies from the \texttt{Sign} oracle. The oracle returns valid signatures if the queried attributes satisfy the signing policy.

        \item Forgery: The adversary outputs a forged signature $(M^*, T^*, \sigma^*)$ for a message $M^*$ and policy $T^*$. The adversary wins if the following conditions hold:
        \begin{itemize}
            \item The adversary did not request a signature on $(M^*, T^*)$ from the \texttt{Sign} oracle.
            \item The adversary does not possess a private key whose attributes satisfy the policy $T^*$.
            \item The verification algorithm accepts $\sigma^*$ as a valid signature under $T^*$.
        \end{itemize}
    \end{itemize}

    \item[Definition II.] Existential Unforgeability under Chosen-Message Attacks (EU-CMA).\\
    An adversary $\mathcal{A}$ is given access to public parameters, hash oracles, and a signing oracle.
    The scheme is secure if $\mathcal{A}$ cannot forge a valid signature $\sigma^*$ for a new message $M^*$ without knowing the signer's full private key.
    In other words, to create an existential forgery, i.e., output a valid pair of message and signature for a new message, an adversary carrying out a CMA can request valid signatures for any message of his choice \cite{Goldwasser1988}.
    The adversary's advantage in this game is its probability of generating a valid forgery.
    We say the ABS scheme is \textit{existentially unforgeable} if the adversary's advantage is negligible.

    \item[Theorem I.] $\mathcal{S}_{CASA}$ is EU-CMA secure under the Computational Diffie-Hellman (CDH) assumption in the random oracle model.\\
    \textit{Proof.} After querying the signing oracle, assume $\mathcal{A}$ forges a signature $\sigma^*$ for $M^*$ for $ M^*$. The challenger interacts with $\mathcal{A}$ as follows:
    \begin{itemize}
        \item \textit{Setup}: The challenger generates $pk$, $p$, and hash oracles \( H_1, H_2, H_3 \) for \( \mathcal{A} \).
        \item \textit{HashQueries}: The challenger responds to \( H_1, H_2, H_3 \) queries with random values, ensuring consistency.
        \item \textit{SigningQueries}: For $M$ and $\mathsf{Att}_{i}$, the challenger computes:
        \[
        \sigma_i = \big(ppk_{i} \cdot H_3(h)\big)^{x_i},
        \]
        where $h = H_2(M || \mathsf{Att}_{i})$.
        \item \textit{Forgery}: If \( \mathcal{A} \) outputs \( \sigma^* \) for \( M^* \), the challenger extracts \( g^{ab} \) from \( g, g^a, g^b \), solving the CDH problem.
    \end{itemize}
    Thus, $\mathcal{A}$'s advantage is negligible under the CDH assumption. The $\mathcal{S}_{CASA}$ scheme is secure against EU-CMA attacks.

    \item[Definition III.] Collusion Attack.\\
    An adversary $\mathcal{A}$ colludes with the CAPP and corrupted signers to derive private keys or forge valid signatures.
    The scheme is secure if such a collusion does not compromise honest signers and does not allow forgery.

    \item[Theorem II.] $\mathcal{S}_{CASA}$ resists collusion attacks under the Discrete Logarithm Problem (DLP).\\
    \textit{Proof.} Suppose $\mathcal{A}$ colludes with the CAPP to derive $sk_i = (ppk_i, \chi_i)$, then the following steps are performed:
    \begin{itemize}
        \item The CAPP knows $ppk_i = H_1(\mathsf{ID}_i || \mathsf{ATT}_i)^{p}$, but $\chi_i$ is chosen independently by the signer.
        \item The DLP ensures $\mathcal{A}$ cannot derive $\chi_i$ from $y_i = g^{\chi_i}$.
        \item Without $\chi_i$, $\mathcal{A}$ cannot compute:
        \[
        \sigma_i = \big(ppk_i \cdot H_3(h)\big)^{\chi_i}.
        \]
    \end{itemize}
    Thus, collusion cannot compromise security. The $\mathcal{S}_{CASA}$ scheme is secure against collusion attacks.

    \item[Theorem III.] CASC-SAS is resistant against replay attacks.\\
    \todo{Add proof.}
\end{description}

\section{Security Compositions}
\todo{TODO: Security compositions for SABAAC}

\section{Performance Analysis}
\todo{TODO: Security analysis for CASC-SAS}

\section{Compatibility Analysis}
\todo{TODO: Compatibility analysis for CASC-SAS}
Maybe physical compatibility, communication compatibility, economy ("price compatibility")\dots

\section{Discussion}
\todo{TODO: Discussion of results and comparison to different approaches}

\section{Limitations}
\label{sec:approach:limitations}
\todo{TODO: Reactivate reference in approach introduction}
\todo{TODO: Limitations: No intrusion detection but prevention/mitigation, might not be usable for fast messages, not every crypto for every message type, possible new attack vectors by adding new components, applicability to other ics domains, time protocol interference, physical access control -> future work}