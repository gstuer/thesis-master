\chapter{Approach}
\label{ch:approach}
In the following section, we introduce our proposed security approach for substation automation systems.
With the aim of securing the time-critical communication between resource-constrained devices in a time-variable environment, we propose a \textbf{C}ertificateless \textbf{A}ttribute-Based \textbf{S}erver-Aided \textbf{C}ryptosystem for \textbf{S}ubstation \textbf{A}utomation \textbf{S}ystems (CASC-SAS).
The CASC-SAS cryptography and cybersecurity approach is able to prevent and mitigate cyberattacks by providing security schemes and mechanisms, and enforcing mandatory communication policies.

The introduction and discussion of the proposed approach is organized as follows.
At the beginning of this chapter in \autoref{sec:approach:system_model}, we discuss the field of application of the proposed approach by introducing a system model and defining its requirements.
Based on the presented system model and requirements, we introduce the security model of the CASC-SAS approach in \autoref{sec:approach:security_model}.
The two main CASC-SAS concepts, its cryptographic scheme and server-aided access control, are introduced in \autoref{sec:approach:casa} and \autoref{sec:approach:sabac}.
In \autoref{sec:approach:realization} we present the planned realization of the CASC-SAS approach.
Subsequently, we present the proposed evaluation strategies and metrics of the approach in \autoref{sec:approach:evaluation}.
Finally, in \autoref{sec:approach:limitations} we discuss limitations of the proposed approach.
%\todo{Own idea, concept, protocol, evaluation, proof, testing, expected benefits and limitations}
%\todo{SECURITY: Security Goals (CIA + Privacy Preserving)}
%\todo{IDEA: Wrap packages of arbitrary protocols by encripting payload of ethernet package, and adding a new header with ABAC-SS information. Maybe as HW Middleware? If other endpoint does not support the ABAC-SS wrapping fall back to proofing endpoint via identity provider only.}
%\todo{PERF EVALUATION: 1. Run approach on network simulator, and 2. Run approach on raspberry pi's representing different roles like server, DER, user \dots}

\section{System Model}
\label{sec:approach:system_model}
In the following sections, we introduce the system model of the CASC-SAS approach.
The system model serves the purpose of delimiting the scope and area of application of the proposed approach.

The area of application of the proposed approach consists of ICSs in the power system domain.
More specifically, the proposed approach is tailored to the communication and control systems of substations in the electricity grid.
The communication and control equipment of an ICS is referred to as secondary equipment.
The entirety of secondary equipment of a substation is referred to as Substation Automation System (SAS) \cite{Padilla2015}.
Although the proposed approach is tailored to the power system domain and substation environment, its main concepts may also be applied to other ICS with similar requirements and constraints.

\subsection{Architecture}
The architecture of the presented system model and SAS respectively is based on the IEC 61850 standard \cite{IEC61850P5}.
The presented system model architecture consists of four layers called network level, station level, bay level, and process level.
The process, bay, and station level represent the internal layers of a SAS architecture.
The SAS architecture containing the process, bay, and station level as well as the station and process bus further discussed in \autoref{sec:approach:system_model:communication} is shown in \autoref{fig:substation_architecture}.
The network level represents a SAS-external layer to integrate multiple SAS instances and supervisory controllers into a comprehensive power system.
Each of the four layers consists of different devices and provides different control and automation functions:
\begin{enumerate}
    \item Process Level: The process level provides functions to interact with the physical process via sensors and actuators.
    As a consequence, SAS devices located at the process level provide interfaces to the physical process.
    In other words, devices located at the process level transform analog measurement signals or control signals into digital values and vice versa.
    Devices restricted to the transformation and provision of measurement and control values are referred to as Merging Units (MU).
    Moreover, IEDs can be employed to combine MU functions with higher-level functions such as protection or communication tasks.

    \item Bay Level: The bay level provides common functions of so-called bays of a SAS.
    As stated by the \citeauthor{IEC61850P5} \cite{IEC61850P5}, a bay represents a closely connected subpart of a substation with common functionality.
    The devices at bay level supervise the operation of lower-level devices of a SAS bay.
    Consequently, a supervising bay level device is referred to as bay controller or bay protection.

    \item Station Level: The station level provides functions related to the substation as a whole.
    Therefore, the station level comprises devices required for on-site and remote monitoring and control of the substation.
    Devices at the station level include Human Machine Interfaces (HMI) for substation operators as well as Wide Area Network (WAN) gateways like SCADA RTUs.

    \item Network Level: The network level provides higher-level functions exceeding the scope of a single SAS.
    The network level devices include supervisory monitoring and control devices like SCADA MTUs.
\end{enumerate}
\begin{figure}
	\centering
	\includegraphics[width=1.0\linewidth]{figures/substation_architecture.drawio.pdf}
	\caption{The internal SAS architecture consisting of three layers called system level, bay level, and process level which are connected via station bus and process bus.}
	\label{fig:substation_architecture}
\end{figure}

\subsection{Communication}
\label{sec:approach:system_model:communication}
In the following, we discuss the communication between devices of the presented system model.
For this purpose, we identify different communication characteristics based on which communication relationships and messages can be classified.
Moreover, we define three messages types for time-critical ICS and SAS communication.
Furthermore, we discuss the bus-based device interactions occurring in the above-mentioned four layer system model.

\subsubsection{Classification Characteristics}
The communication relationships between devices can be classified using different communication characteristics.
Topological communication characteristics can be used to classify the device relationships based on their relative or absolute location within the system model.
Accordingly, communication can either occur between devices on the same layer or different layers of the system model.
Communication on the same layer of the system model is referred to as horizontal communication, whereas communication between devices on different layers is referred to as vertical communication.
Moreover, communication can occur between devices of the same or different subsystems.
Communication between devices of the same subsystem is classified as (subsystem) internal communication, whereas communication relationships including an external device are classified as (subsystem) external communication.
Furthermore, a communication relationship is not limited to a single receiver (unicast) but rather a group of devices (multicast) or all devices (broadcast) may receive a sender's message.

Besides the topology-based classification, communication relationships can be classified based on their continuity.
Continuous, session-oriented, or stateful communication requires an initial session establishment between the involved devices.
While the first message exchange requires additional initialization overhead, subsequent latencies might benefit from the established communication session.
Discontinuous, message-oriented, or stateless communication enables communication without initial overhead for the involved devices.
Consequently, discontinuous communication does not lead to latency emerging from session initialization and management.

Since communication in ICS and SAS is time-critical, communication relationships can be classified based on their communication latency constraints.
Within the scope of the proposed approach, we define communication latency as sum of processing times and transmission times required to exchange information between involved devices.
The transmission time is the time required to transmit a message over a network link with a specific throughput.
The processing time represents the time required for a device to send, forward, or receive a message or packet.
For intermediate network devices like routers and switches the processing time depends on queuing delay and forwarding delay.
For the sender and receiver of a message or packet the processing time consists of enqueue and dequeue delays, cryptographic overhead, and message coding.
As a consequence, the communication latency represents the time required for a message from being put into the sending buffer at the sender to the point when the message is taken from the receiving buffer at the receiver.

\subsubsection{Message Types}
The defined message types of the presented system model are based on the classification characteristics defined above and on the message types and performance classes of the IEC 61850 standard \cite{IEC61850P5}.
The defined message type as well as their typical communication topology, continuity, and latency constraints are shown in \autoref{tab:message_types}.

The low latency message type corresponds to the IEC 61850 \cite{IEC61850P5} message types 1A and 4.
The low latency messages are used for SAS-internal exchange of sampled values and state values.
In IEC 61850 compliant substations the sampled values are exchanged using the Sampled Values (SV) protocol between MUs and IEDs (vertical) or between MUs (horizontal).
Moreover, state values and state changes are exchanged horizontally between IEDs using the Generic Object Oriented Substation Events (GOOSE) protocol.

The medium latency message type corresponds to the IEC 61850 message types 1B and 2.
The medium latency messages are used for internal and external as well as horizontal and vertical session-based client-server communication.
In IEC 61850 substations IEDs use the Manufacturing Message Specification (MMS) protocol to communicate with other IEDs and higher-level devices.

The high latency message type corresponds to the IEC 61850 message types 3 and 5.
This message type is used for HMI interactions as well as non-time-critical operations like file transfers.
In IEC 61850 substations MMS as well as SCADA protocols are used for high latency communication.
\begin{table}
    \centering
    \caption{Message types of the presented system model classified with regard to their topology, continuity, and latency constraints of the communication relationships.}
    \label{tab:message_types}
    \begin{tabular}{l c c c c c}
    \toprule
    \multicolumn{1}{c}{Message Type} & \multicolumn{3}{c}{Topology} & Continuity & Latency\\
    & Externality & Verticality & Receiver & & Constraint\\
    \midrule
    Low Latency & Internal & Horiz./Vert. & Multicast & Message-Based & 3 ms\\
    Medium Latency & Int./Ext. & Horiz./Vert. & Unicast & Session-Based & 20-100 ms\\
    High Latency & Int./Ext. & Horiz./Vert. & Unicast & Session-Based & 500 ms\\
    \bottomrule
    \end{tabular}
\end{table}

\subsubsection{Communication Buses}
The presented system model uses a bus-based approach for SAS-internal message exchange between the system architecture layers.
The implementation of SAS-internal buses is typically based on Ethernet and open or proprietary fieldbus technology.
The bus-based approach as well as the two concrete buses introduced in the following are based on the IEC 61850 standard \cite{IEC61850P5}.

The first bus for SAS-internal message exchange is referred to as process bus.
The process bus is located between the bay level and the process level.
The process bus is used for time-critical message-based publisher-subscriber communication.
GOOSE and SV are the IEC 61850 protocols used for process bus communication.

The second bus for SAS-internal message exchange is referred to as station bus.
The station bus is located between the station level and the bay level.
The station bus connects IEDs at the bay level with each other as well as with gateways and interfaces at the station level.
The communication at the station bus is typically session-based unicast communication with less strict time requirements compared to the process bus.

SAS-external message exchange between devices on the station level and network level use WAN telecommunication technologies including Internet, satellite, cellular, and radio technology.
Secure tunneling approaches like Virtual Private Networks (VPN) can be used to enhance the security of SAS message exchange over an unsecure communication medium.

%\subsection{Threats}
%\todo{System Threats + Adversaries + Attack Trees}

\subsection{Requirements}
In the following, we introduce the requirements of the presented system model.
Based on the identified requirements, functional and non-functional characteristics of the proposed approach are derived and evaluated.
Each system model requirement is associated with a requirement category.
We define five requirement categories for the introduced system requirements.
The requirement categories include security (RQ.SEC), safety (RQ.SAFE), availability (RQ.AVA), performance (RQ.PERF), and interoperability (RQ.INT).
\todo{Add forward/backward secrecy and more.}

%\subsubsection{Security}
\paragraph{RQ.SEC.1 Confidentiality}
The system prohibits unauthorized access to sensitive information stored on devices and payload of messages exchanged within the system and between systems \cite{Eckert2023}.
\paragraph{RQ.SEC.2 Integrity}
The system detects unauthorized manipulation of stored and exchanged data \cite{Eckert2023}.
\paragraph{RQ.SEC.3 Authenticity}
The system can proof the authenticity and trustworthiness of subjects and data objects present in the system \cite{Eckert2023}.
\paragraph{RQ.SEC.4 Non-Repudiation}
The system ensures that a subject cannot dispute its authorship of data and requests \cite{Eckert2023}.
\paragraph{RQ.SEC.5 Least Privilege Principle (PoLP)}
The system ensures that each subject has the least number of privileges necessary to perform its function \cite{JTF2020}.
\paragraph{RQ.SEC.6 Separation of Duties (SoD)}
The system ensures that no subject has enough privileges to be able to misuse the system without collusion \cite{JTF2020}.
\paragraph{RQ.SEC.7 Privacy-Preservation}
\todo{TODO: Does this conflict with the idea of proofing the origin of a request? In other words, is it possible to check if the subject who requested the access decision is still the same subject who used it in its request?}

%\subsubsection{Safety}
\paragraph{RQ.SAFE.1 Safe Operation}
\paragraph{RQ.SAFE.2 Fail-Safe}

%\subsubsection{Availability}
\paragraph{RQ.AVA.1 Continuing Operation}
\paragraph{RQ.AVA.2 Fail-Operational}

%\subsubsection{Performance}
\paragraph{RQ.PERF.1 Communication Latency}
\paragraph{RQ.PERF.2 Computational Complexity}
\paragraph{RQ.PERF.3 Energy \& Power Saving}

%\subsubsection{Interoperability}
\paragraph{RQ.INT.1 Compatibility}
\paragraph{RQ.INT.2 Interchangeability}

\section{Security Model}
\label{sec:approach:security_model}
\subsection{Security Architecture}
\todo{Architecture: CASC-SAS Components \& Layers \& Busses}
\subsubsection{Layers \& Buses}
\subsubsection{Components}
\subsubsection{Stakeholders}

\subsection{Security Policies}
\todo{Security Policies -> Link to Requirements \& Attacks}

\section{Certificateless Attribute-Based Server-Aided Authentication (CASA)}
\label{sec:approach:casa}
In the following section, we present the \textbf{C}ertificateless \textbf{A}ttribute-Based \textbf{S}erver-Aided \textbf{A}uthentication (CASA) concept.
CASA is a certificateless public key cryptography (CL-PKC) approach.
The goal of CASA is to provide cryptographic algorithms and schemes for key generation, key distribution, key revocation, signing, and verification.
Moreover, the goal of CASA is to enable and support more abstract cybersecurity mechanisms like authorization and access control of the CASC-SAS approach.
Therefore, CASA represents the foundation of the employed CASC-SAS cybersecurity mechanisms.

As stated by \citeauthor{AlRiyami2003} \cite{AlRiyami2003}, CL-PKC can be seen as an intermediate approach between certificate-based PKC approaches like Public Key Infrastructure (PKI) and Identity-Based PKC (ID-PKC).
On the one hand, Certificate-based PKC approaches like PKI use a Trusted Third Party (TTP) called Certificate Authority (CA) to issue and store digital certificates.
These digital certificates are used to verify that a certain public key belongs to a specific subject which holds the corresponding private key.
On the other hand, ID-PKC approaches allow the derivation of public keys from subject identities.
The concept of identity-based cryptosystems and schemes was initially proposed by \citeauthor{Shamir1985} \cite{Shamir1985}.
As a consequence, the existence of a public key no longer depends on the existence of a corresponding private key.
Moreover, no certificates are required to verify that a public key belongs to a certain subject, since the subject identity is used to derive the public key.
Nevertheless, in ID-PKC a TTP called Private Key Generator (PKG) is used to generate private keys for subjects based on a system-wide master key.
This leads to key escrow and allows a misbehaving PKG to decrypt confidential messages and forge subject's signatures.

Since CASA is a CL-PKC approach, neither certificates nor key escrow is required.
As proposed by \citeauthor{AlRiyami2003} \cite{AlRiyami2003}, CL-PKC approaches like CASA make use of a TTP called Key Generating Center (KGC) to generate partial private keys for entities based on the entity's identity and a master key.
In order to generate the private key, the entity combines the partial private key with a secret value.
Consequently, the KGC has no access to the private key and no secure channel is required for the key distribution.
According to \citeauthor{AlRiyami2003}, the public key is generated by the entity based on system-wide public parameters and the secret value.
Moreover, the CASA approach proposes a key generation that is not only based on subject identities but rather enables public keys and private keys based on arbitrary attributes of subjects or even groups of subjects.

The key generation of the CASA approach is based on an alternative CL-PKC key generation technique proposed by \citeauthor{AlRiyami2003}.
The defining characteristics of the alternative key generation is the derivation of partial private keys from public keys and identities.
As a consequence, an entity has to generate its public key before it can request a partial private key from the KGC.
This alternative key generation enables sending of partial private keys over unsecure channels and reduces the required trust in the KGC.
Furthermore, this technique allows only one public key to be created for a specific private key.

\subsection{Server-Aided Cryptography}
As PKC mechanisms may consist of computationally complex algorithms and operations such as bilinear pairing, we propose a server-aided PKC approach.
Therefor, we propose an extension of the CL-PKC concept and schemes to make time-critical steps server-aided.
In order to make CASA server-aided, an Untrusted Cryptography Server (UCS) supports devices by handling computationally expensive algorithms instead of executing them locally on resource-constraint devices.
To minimize the required trust, the UCS may only handle certain computations, i.e., partially sign or verify a request of a device.
This server-aided approach enables resource-constraint devices to apply secure algorithms and schemes of CASA in a time-critical OT environment.
In the following, we employ the concept of server-aided PKC for the verification process.

As stated by \citeauthor{Wu2008} \cite{Wu2008}, a server-aided verification process has to satisfy the property of being computation-saving.
A server-aided verification process $V_{Aided}$ is computation-saving if the computational costs for the verifier are strictly less than the costs of non-server-aided verification $V_{Conventional}$.
In other words, $V_{Aided}$ is computation-saving if the equation $Cost(V_{Aided}) < Cost(V_{Conventional})$ holds.

\subsection{Online \& Offline Cryptography}
Since CASA is tailored for time-critical communication, the approach aims to reduce the required time for cryptographic algorithms.
In addition to server-aided cryptography, this time reduction is achieved by precomputation.
For this purpose, each step of an algorithm is classified as either online or offline.
Online steps depend on the sender's public key, the digital signature, or the message.
Consequently, online steps cannot be precomputed.
Nevertheless, specific online steps can be accelerated via server-aided cryptography.
Offline steps depend on information that is available before any message exchange occurs.
Therefore, offline steps can be precomputed to reduce the required time for cryptographic algorithms.

\subsection{Signature Scheme $\mathcal{S}_{CASA}$}
The CASA signature scheme $\mathcal{S}_{CASA} = (I, G_{VAL}, G_{PK}, G_{PPK}, G_{SK}, S, V_{ENT}, V_{SAV}, V_{FIN})$ is a nine-tuple of algorithms.
The algorithms comprise an initialization algorithm $I$, a secret value generation algorithm $G_{VAL}$, a public key generation algorithm $G_{PK}$, a partial private key generation algorithm $G_{PPK}$, a private key generation algorithm $G_{SK}$, a signing algorithm $S$, a partial entity verification algorithm $V_{ENT}$, a partial server verification algorithm $V_{SAV}$, and a final entity verification algorithm $V_{FIN}$.
In the following sections, the specific algorithms are further discussed.

The definition of the CASA signature scheme is based on the definition of digital signature schemes provided by \citeauthor{Boneh2023} \cite{Boneh2023}.
Moreover, since CASA is a CL-PKC approach, the signature scheme is based on the schemes and concepts presented by \citeauthor{AlRiyami2003} \cite{AlRiyami2003} and \citeauthor{Ramadan2023} \cite{Ramadan2023}.
The proposed server-aided verification concept and algorithms are based on schemes proposed by \citeauthor{Ramadan2020} \cite{Ramadan2020}, \citeauthor{Girault2005} \cite{Girault2005} and \citeauthor{Wu2008} \cite{Wu2008}.

\subsubsection{Initialization Algorithm $I$}
The initialization algorithm $(\rho, s) \leftarrow I(\lambda)$ takes the security parameter $\lambda$ as input and outputs the public system parameters $\rho$ and the private master key $s$.
The initialization algorithm is executed by the KGC.
After the execution, $\rho$ is publicly available to all entities, whereas $s$ is only known by the KGC.

\subsubsection{Secret Value Generation Algorithm $G_{VAL}$}
The secret value generation algorithm $\chi_A \leftarrow G_{VAL}(\rho)$ takes the public system parameters $\rho$ as input and outputs the secret value $\chi_A$ of an entity $A$.
The secret value generation algorithm is executed by an entity.
The secret value $\chi_A$ is never shared with other entities and may only be known to entity $A$.

\subsubsection{Public Key Generation Algorithm $G_{PK}$}
The public key generation algorithm $pk_A \leftarrow G_{PK}(\rho, \chi_A, ID_A)$ takes the public system parameters $\rho$, the secret value of an entity $\chi_A$, and the defining attributes of entity $A$ $ID_A$ as input.
The algorithm outputs the public verification key $pk_A$ of entity $A$.
The algorithm is executed by an entity.

\subsubsection{Partial Private Key Generation Algorithm $G_{PPK}$}
The partial private key generation algorithm $ppk_A \leftarrow G_{PPK}(\rho, s, ID_A, pk_A)$ takes the public system parameters $\rho$, the private master key of the KGC $s$, the defining attributes of entity $A$ $ID_A$, and the $A$'s public verification key $pk_A$ as input.
The algorithm outputs the partial private key $ppk_A$ of entity $A$.
The partial private key generation is executed by the KGC on request of an entity.
After the execution, the KGC provides the partial private key to the corresponding entity.

\subsubsection{Private Key Generation Algorithm $G_{SK}$}
The private key generation algorithm $sk_A \leftarrow G_{SK}(\rho, \chi_A, ppk_A)$ takes the public system parameters $\rho$, the secret value of an entity $\chi_A$, and the partial private key $ppk_A$ of entity $A$ as input.
The algorithm outputs the private signing key $sk_A$ of entity $A$.

\subsubsection{Signing Algorithm $S$}
The signing algorithm $\sigma \leftarrow S(sk_A, m)$ takes the private signing key $sk_A$ and message $m$ as input, and outputs the signature $\sigma$.
In other words, the signing algorithm $S$ is used by the sender $A$ of a message $m$ to generate a digital signature $\sigma$.
The generated digital signature $\sigma$ is associated with the message $m$ and the sender's private signing key $sk_A$.
\todo{Introduce Server-Aided Signing Techniques (Server-Partial-Signing, Sender-Signing) and Online/Offline Algorithm Steps.}

\subsubsection{Partial Entity Verification Algorithm $V_{ENT}$}
The partial entity verification algorithm $\sigma_{ENT} \leftarrow V_{ENT}(\rho, pk_A, m, \sigma)$ represents the first step of the server-aided verification process.
The algorithm takes the public system parameters $\rho$, the public verification key $pk_A$ of entity $A$, the message $m$, and the signature $\sigma$ as input.
The algorithm outputs the partially verified signature $\sigma_{ENT}$.
The receiver of a message executes the partial entity verification algorithm $V_{ENT}$ and sends the partially verified signature $\sigma_{ENT}$ to the UCS for server-aided verification.

\subsubsection{Partial Server Verification Algorithm $V_{SAV}$}
The partial server verification algorithm $\sigma_{SAV} \leftarrow V_{SAV}(\sigma_{ENT})$ represents the second step of the server-aided verification process.
The algorithm takes the partially verified signature $\sigma_{ENT}$ as input and outputs the partially verified signature $\sigma_{SAV}$.
The algorithm is executed by the UCS on request of a message receiving entity.
After the execution, the UCS provides the partially verified signature $\sigma_{SAV}$ to the requestor.

\subsubsection{Final Entity Verification Algorithm $V_{FIN}$}
The final entity verification algorithm $\delta \in \{accept, reject\} \leftarrow V_{FIN}(\rho, pk_A, m, \sigma, \sigma_{ENT}, \sigma_{SAV})$ represents the third and last step of the server-aided verification process.
The algorithm takes the public system parameters $\rho$, the public verification key $pk_A$ of entity $A$, the message $m$, the signature $\sigma$, and the partially verified signatures $\sigma_{ENT}$ and $\sigma_{SAV}$ as input.
The algorithm outputs the verification decision $\delta$ which is either $accept$ or $reject$.
In other words, the verification algorithm $V_{FIN}$ is used by the receiver to verify a received message $m$ sent by entity $A$ based on an appended signature $\sigma$.
As $\sigma$ is associated with the message $m$ and the sender's private signing key $sk_A$, it allows the receiver to verify the integrity and authenticity of the received message $m$ using the sender's public verification key $pk_A$.

\subsection{Security Model}
According to the definition of \citeauthor{Boneh2023} \cite{Boneh2023} as well as \citeauthor{Goldwasser1988} \cite{Goldwasser1988}, the proposed signature scheme $\mathcal{S}_{CASA}$ is a secure signature scheme if it is existentially unforgeable under an adaptive chosen-message attack (CMA).
In order to create an existential forgery, i.e., output a valid pair of message and signature for a new message, an adversary carrying out a CMA can request valid signatures from an entity for any message of his choice.
While non-adaptive CMA restricts the adversary to a fixed set of messages chosen prior to the attack, adaptive CMA allows the adversary to request signatures of messages depending on previously obtained signatures.
\citeauthor{Goldwasser1988} describe an adaptive CMA as most powerful attack possible for an enemy restricted to using the signature scheme.

\section{Server-Aided ABAC (SABAC)}
\label{sec:approach:sabac}
\todo{Server-Aided ABAC: is Delegated AC, Distributed Evaluation Strategy (With PDP, Ad-Hoc, Time Variable Attributes), Policies (Rule/Pol Types:RT/Static, DSL, appropriate message types for pol. types), Requests(External, Internal), Protocols, Session-Based via OAT (Estab. channel before comm.), Semi-Delegated Authentication, Delegated Authorization}
% \subsubsection{Delegated Authorization}
% \todo{Policies (Rule/Pol Types:RT/Static, DSL, appropriate message types for pol. types)}
% \todo{Hierarchic PAPs}
% \subsubsection{Semi-Delegated Authentication}
% \todo{Semi-Delegated Authentication}
% \subsubsection{Delegated Authentication}

% \subsubsection{Access Control Protocol}
% \paragraph{Unicast: Client-Server Protocol}
% \paragraph{Multicast \& Broadcast: Publisher-Subscriber Protocol}

\section{Realization}
\label{sec:approach:realization}
\todo{Realization: HW (BITW) or Software Solution}

\section{Evaluation}
\label{sec:approach:evaluation}
\subsection{Evaluation Areas \& Metrics}
\subsubsection{Security Evaluation}
\subsubsection{Performance Evaluation}
\subsubsection{Economic Evaluation}

\subsection{Network Testbed}
\todo{Network Testbed}

\subsection{Network Simulation}
\todo{Network Simulation}

\section{Limitations}
\label{sec:approach:limitations}
\todo{Limitations: No intrusion detection but prevention/mitigation, might not be usable for fast messages, not every crypto for every message type, possible new attack vectors by adding new components, applicability to other ics domains, time protocol interference, physical access control -> future work}
